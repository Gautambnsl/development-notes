# 4. Angular

## Basics

* Angular is a Javascript Framework which allows you to create reactive Single-Page-Applications \(SPAs\)
* Angular 1 \(now referred as Angular JS it's totally different\) Obsolete now it has been rewritten
* Angular 2 -&gt; Angular 4 -&gt; ... -&gt; Angular 9 -&gt; Angular 11 \(Nothing changed since Angular 2\)
* Install Angular CLI using npm
* create new project using `ng new my-first-project`
* It's advanced version of Javascript. Simple Janilla Javascript lacks types, classes, Interfaces
* Typescript gets compiled to Javascript then run in browser but this compilation is very fast

### Setting up Bootstrap

* npm install --save bootstrap
* Then in angular.json in styles add path `"node_modules/bootstrap/dist/css/bootstrap.min.css"`Before default styles.css

### Create Component

* Angular uses bunch of modules, default is app  module which has declaration of all components within that module, imports are external modules which are imported.
* App Component is then called, each component has seperate css, ts, html and .spec.ts \(for testing\)
* You can manually create a new component, put in new folder take care of naming convention and add it to module or type `ng generate component servers`

### Data Binding

* Shows data from typescript to html

```typescript
export class ServerComponent implements OnInit {
    serverId: number = 10;
    serverStatus: string = 'offline';

    constructor() { }
    ngOnInit() { }
}

// In HTML
<p>Server with {{ serverId }} is {{ serverStatus }}</p>
```

### Property & Event Binding

* Change some property of Element/Component \(uses \[...\]\)
* Do some event \(uses \(...\)\)

```typescript
export class ServersComponent implements OnInit {
  allowNewServer = false;

  constructor() {
    setTimeout(() => {
      this.allowNewServer = true;
    }, 2000);
  }
  ngOnInit(): void {
  }
}

// In HTML

<button
  class="btn btn-primary"
  [disabled]="!allowNewServer"
  (click)="onClickAddServer($event)"
>
  Add Server
</button>
```

### Two Way Binding

* Two way bind data say for textbox, here it uses a special directive ng-model

```typescript
// HTML
<input type="text" class="form-control" [(ngModel)]="serverName" />

// Make sure to import this in App module
import { FormsModule } from '@angular/forms';
// And put this inside imports of App module
FormsModule
```

### Built-in Directives

* Directives are instructions in the DOM

> \#noServer in below is a reference to an HTML component which can be refereed within HTML document. To use it in TS `@ViewChild('name-of-ref') refVariable: ElementRef;`Now we can use refVariable. Get element using - `refVariable.nativeElement.value;`

```typescript
// * because it's a structural directive
<p *ngIf="serverCreated; else noServer">Server was created!</p>
<ng-template #noServer>
    <p>No Server was created!</p>
</ng-template>

/* severCreated is a bool defined in component.ts
ng-template marks a portion with some tag, so that it can be used later
*/

// ngStyle derrivative, here it's binded with getColor method that's why inside []
<p [ngStyle]="{backgroundColor: getColor()}">{{ status }}</p>

// ngClass, it adds css class based on condition specified
<p [ngClass]="{online: isOnline, offline: !isOnline}">{{ status }}</p>

// ngFor
<p *ngFor="let item of items">{{ item }}</p>
```

> You can also create nameOfComponent.model.ts file to store some typeScript class maybe like a data class which is getting instanced in the original component.ts

> Install Augury Chrome Extension

## Components & Data Binding

### Send custom Data from parent to child

```typescript
// parent.html
<app-server-element
  *ngFor="let serverElement of serverElements"
  [element]="serverElement"
></app-server-element>

// child.ts
export class ServerElementComponent implements OnInit {
  @Input() element: { type: string, name: string, content: string };

  constructor() { }
  ngOnInit(): void { }
}

// child.html
{{ element.name }}
```

* Without @Input decorator the variable won't be accessible as property
* You can set an alias instead of variable name by `@Input('alias-instead-of-variable-name')`

### Get Event callback from child to parent

```typescript
// child.ts
export class CockpitComponent implements OnInit {

  @Output() serverCreated = new EventEmitter<{ serverName: string, serverContent: string }>();
  @Output() blueprintCreated = new EventEmitter<{ blueprintName: string, blueprintContent: string }>();
  newServerName = '';
  newServerContent = '';

  constructor() { }
  ngOnInit(): void { }
  onAddServer() {    // called by button in child.html
    this.serverCreated.emit({ serverName: this.newServerName, serverContent: this.newServerContent });
  }
  onAddBlueprint() {    // called by button in child.html
    this.blueprintCreated.emit({ blueprintName: this.newServerName, blueprintContent: this.newServerContent });
  }
}

// parent.html
<app-cockpit
  (serverCreated)="onServerAdded($event)"
  (blueprintCreated)="onBlueprintAdded($event)"
></app-cockpit>
```

* You can set an alias instead of variable name by `@Output('alias-instead-of-variable-name')`

### View Encapsulation

> CSS defined in a component say for p, then it gets applied for all p element However in Angular it gets applied to only that component. It's a great behaviour as it ensures that whichever css we apply gets applied to the same css.
>
> How Angular does that, is it basically adds attribute to each element based on what component it belongs to like ng0, ng1 then it uses that as selector. There's also a shadow DOM method which is only supported in new browsers

```typescript
// component.ts
@Component({
  selector: 'app-server-element',
  templateUrl: './server-element.component.html',
  styleUrls: ['./server-element.component.css'],
  encapsulation: ViewEncapsulation.Emulated    // use this line
})

/* encapsulation - Emulated is default behaviour
Native is same as Emulated but it uses shadow DOM method which is not supported
by older browsers so Native is not recommended.
Last, there's None which gives default encapsulation behaviour and attribute of
component wont get set. */
```

### Content Hook

By default everything placed inside the custom-component-tag in HTML is lost

```markup
// some-component.html
...
<ng-content></ng-content>
...
```

> This hook puts all the content placed inside while calling &lt;some-component&gt;....&lt;/some-component&gt; to the ng-content place

> Say this content has some \#ref and you want to use it then just like @ViewChild there's @ContentChild `@ContentChild('name-of-ref') refVariable: ElementRef;`

## Lifecycle

![](.gitbook/assets/image%20%2814%29.png)

## Directives

* There are 2 types of directives - Attribute & Structural directives
* Attribute directives changes the attribute like style and stuff, eg: ngStyle, ngClass
* Structural directives changes the structure \(can remove\), eg: \*ngIf, \*ngFor
* To create a new directive `ng generate directive name-of-derrivate` 

### Custom Highlight Attribute Directive

> &lt;p appBetterHighlight \[defaultColor\]="'yellow'" \[highlightColor\]="'red'"&gt;...&lt;/p&gt;

```typescript
import { Directive, ElementRef, HostBinding, HostListener, Input, OnInit, Renderer2 } from '@angular/core';

@Directive({
  selector: '[appBetterHighlight]'
})
export class BetterHighlightDirective implements OnInit {
  @Input() defaultColor: string = 'transparent';
  @Input() highlightColor: string = 'blue';
  @HostBinding('style.backgroundColor') backgroundColor: string;

  constructor(private elRef: ElementRef, private renderer: Renderer2) { }
  ngOnInit() { }

  @HostListener('mouseenter') mouseEnter(eventData: Event) {
    this.backgroundColor = this.highlightColor;
  }
  @HostListener('mouseleave') mouseLeave(eventData: Event) {
    this.backgroundColor = this.defaultColor;
  }
}
```

### Custom Structural Directive

> &lt;div \*appUnless="condition"&gt;...&lt;/div&gt;

```typescript
import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';

@Directive({
  selector: '[appUnless]'
})
export class UnlessDirective {
  @Input() set appUnless(condition: boolean) {
    if (!condition) {
      this.vcRef.createEmbeddedView(this.templateRef);
    } else {
      this.vcRef.clear();
    }
  }

  constructor(private templateRef: TemplateRef<any>, private vcRef: ViewContainerRef) { }
}
```

### ngSwitch

```markup
<div [ngSwitch]="value">
  <p *ngSwitchCase="5">Value is 5</p>
  <p *ngSwitchCase="10">Value is 10</p>
  <p *ngSwitchDefault>Value is 10</p>
</div>
```

### Custom Dropdown Directive - Attach CSS

```typescript
import { Directive, HostBinding, HostListener } from '@angular/core';

@Directive({
  selector: '[appDropdown]'
})
export class DropdownDirective {
  @HostBinding('class.open') isOpen = false;

  @HostListener('click') toggleOpen() {
    this.isOpen = !this.isOpen;
  }
}
```

## Services

* Use `ng generate service name-of-service` 
* To use the new service in say your xyz.ts file add `providers: [LoggingService]` to @Component and then `constructor(private loggingService: LoggingService) {}` then you can simply call the service by `this.loggingService.logStatusChange(accountStatus)` 

```typescript
// LoggingService.ts
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class LoggingService {
  logStatusChange(msg: string) { console.log(msg); }
}
```

> This provider dependency injector is hierarchial in nature that means if we provide the service \(using providers\) to a component than that component and all it's child will get that service and that too of same instance, so data within service will be shared.

## Routing

```typescript
// app.module.ts

const appRoutes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'users/:id', component: UsersComponent },
  { path: 'servers', component: ServersComponent }
];

// Then in it's imports array add
RouterModule.forRoot(appRoutes)

// Finally in app.component.html add
<router-outlet></router-outlet>
// to the place where you want the router to show
```

> To get route param, in the component.ts file of that route add `private route: ActivatedRoute;` to the constructor and then get param by `this.route.snapshot.params['id']` Inside the ngOnInit

* Then `<a href="/servers">..</a>` This works however what it does is it restarts the entire app instead of href use routerLink this will work just like that but doesnt restart app hence more fast
* `/path` goes to rootpath/path whereas if it's `path` and say user is already at /path then it will go to /path/path so it basically will append.
* `../path` This will go back one from current path and then add

```markup
<ul class="nav nav-tabs">
  <li
    role="presentation"
    routerLinkActive="active"
    [routerLinkActiveOptions]="{ exact: true }"
  >
    <a routerLink="/">Home</a>
  </li>
  <li role="presentation" routerLinkActive="active">
    <a routerLink="/servers">Servers</a>
  </li>
  <li role="presentation" routerLinkActive="active">
    <a routerLink="/users">Users</a>
  </li>
</ul>
```

> routerLinkActive add the active css class if that route is active and routerLinkActiveOptions exact makes sure that it is exact since / and /servers both has / in it but we only want home to be active in case of / so that's why exact is required.

* To programmatically route somewhere

```typescript
constructor(private router: Router) { }
onLoadServer() {
    this.router.navigate(['/servers']);
}

// for relative path 'path' instead of '/path' relativeTo needs to be specified
constructor(private router: Router, private route: ActivatedRoute) { }
onLoadServer() {
    this.router.navigate(['/servers'], {relativeTo: this.route});
}
```

> To get params use `this.route.snapshot.param['param_name']` inside ngOnInit however this might not work in a scenerio say there's a button on that component which routes to the same component but with different param. Angular will not reload the component since it knows that component is already there.  
> Add this in ngOnInit

```typescript
paramsSubscription: Subscription;

ngOnInit() {
    this.id = this.route.snapshot.params['id'];
    this.paramsSubscription = this.route.params.subscribe((params: Params) => {
        this.id = params['id'];
    });
}

ngOnDestroy() {
    this.paramsSubscription.unsubscribe();
}

// this params.suscribe is something called observable which is called when
// the event is observed
```

## Observable

## Handling Forms

## Pipes

## HTTP Requests

## Authentication & Route Protection

## Dynamic Components

## Angular Modules & Optimizing Angular Apps

## Deploying

## Angular Universal

## Angular Animations

## Offline Capabilities with Service Workers

## Unit Testing

